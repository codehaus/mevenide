package org.mevenide.idea.util.psi;

import com.intellij.psi.PsiTreeChangeEvent;

/**
 * @author Arik
 */
public interface PsiModifiable {
    /**
     * An enum for specifying what is the source of current event.
     *
     * <p>When the user modifies the UI (not from the text editor), the {@link
     * PsiModifiable#getModificationSource} method should return {@link #UI}. If the user modifies
     * using the text editor, the method should return {@link #EDITOR}.
     *
     * <p>This is done because the code responding to UI modifications updates the PSI tree, which
     * invokes the code responding to PSI modifications, which updates the UI - this can cause an
     * infinite loop, so we need to know who started the loop to avoid it.</p>
     */
    public static enum ModificationSource { UI, EDITOR }

    /**
     * Returns the source of the current modification taking place.
     *
     * <p>This method is called during PSI event processing, or during a Swing event processing to
     * determine if the PSI/Swing event was generated by the user directly or by the listeners.</p>
     *
     * <p>For example, if the user modifies the POM via the Swing widgets, than the swing widgets
     * modify the PSI tree, which generate a PSI event. In the PSI event we must know that the event
     * was originally generated by the source editor and therefor not trigger the Swing models (or
     * an infinite loop will occur).</p>
     *
     * @return the modification source
     */
    ModificationSource getModificationSource();

    /**
     * Sets the source of the current event.
     *
     * @param pSource the event source
     */
    void setModificationSource(ModificationSource pSource);

    /**
     * Completely rebuilds the model from the PSI tree.
     *
     * <p>Usually, this method will call the {@link #refreshModel(PsiEventType,PsiTreeChangeEvent)}
     * method with a {@code null} argument.
     *
     * <p>This method should be {@code final} so that only one place will contain synchronization
     * logic (the {@link #refreshModel(PsiEventType,PsiTreeChangeEvent)} method). When implementing
     * it, make sure you take into account that the event parameter might be {@code null}.</p>
     */
    void refreshModel();

    /**
     * This method must synchronize this model with the PSI model, where the PSI model acts as the
     * source and this model as the destination.
     *
     * <p>A possible approach is to completely build this model's values from the PSI tree, or the
     * incremently apply changes from the supplied PSI event object.</p>
     *
     * <p>If the {@code pEvent} parameter is {@code null}, then a complete rebuild of the model from
     * the PSI tree should be performed.* </p>
     *
     * @param pEventType the PSI event type
     * @param pEvent     the PSI event object. This <i>may</i> be {@code null}
     */
    void refreshModel(PsiEventType pEventType, PsiTreeChangeEvent pEvent);
}
